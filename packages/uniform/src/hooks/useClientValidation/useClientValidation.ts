import type { VetoTypeAny } from '@fuf-stack/veto';

import { useEffect, useId } from 'react';

import { array, objectLoose } from '@fuf-stack/veto';

import { flatArrayKey } from '../../helpers';
import { useFormContext } from '../useFormContext/useFormContext';

/**
 * Hook for adding dynamic client-side validation to forms.
 *
 * Client validation is used for context-dependent validation rules that require external data
 * (e.g., checking if a username already exists). It complements base validation (passed to Form),
 * which handles static rules like "required", min/max length, format, etc.
 *
 * **Typical pattern:**
 * - Base validation: Static, always-on rules (required, format, length constraints)
 * - Client validation: Dynamic rules based on external data (uniqueness, business logic)
 * - Client schemas should use `.nullish()` to allow empty values (base validation handles "required")
 *
 * Automatically manages validation schema lifecycle: sets schema when data is provided,
 * clears schema when data is null/undefined, and cleans up on unmount. When the client
 * validation schema changes, automatically re-validates all touched fields.
 *
 * @param data - Data to create validation schema from (or null/undefined to clear validation)
 * @param schemaFactory - Function that creates a validation schema from the data. Schemas should typically use `.nullish()`.
 * @param options - Optional configuration object
 * @param options.key - Optional custom key for registration. Useful when multiple instances should share validation (e.g., in field arrays)
 *
 * @example
 * ```tsx
 * // Base validation handles "required" and format
 * const baseSchema = veto({ username: vt.string({ min: 3 }) });
 *
 * // Client validation adds dynamic uniqueness check
 * const { data: teamData } = useTeamQuery(teamId);
 * useClientValidation(teamData, (data) =>
 *   vt.objectLoose({
 *     username: vt.string()
 *       .refine(
 *         (value) => !data.existingUsers.includes(value),
 *         { message: 'Username already exists' }
 *       )
 *       .nullish() // Allow empty - base validation handles "required"
 *   })
 * );
 * ```
 *
 * @example
 * ```tsx
 * // Using custom key in a field array to avoid multiple registrations
 * fields.map((field, index) => (
 *   useClientValidation(
 *     userData,
 *     (data) => clientValidationSchemaByName(
 *       `items.${index}.name`,
 *       vt.string()
 *         .refine((val) => !data.forbidden.includes(val), { message: 'Name not allowed' })
 *         .nullish()
 *     ),
 *     { key: 'items-validation' } // All instances share the same key
 *   )
 * ));
 * ```
 */
export const useClientValidation = <TData = unknown>(
  data: TData | null | undefined,
  schemaFactory: (data: TData) => VetoTypeAny,
  options?: { key?: string },
): void => {
  const {
    formState: { touchedFields },
    validation: { setClientValidationSchema },
    trigger,
  } = useFormContext();

  // Use provided key or auto-generate unique key
  const autoGeneratedKey = useId();
  const key = options?.key ?? autoGeneratedKey;

  // Use data hash instead of object reference to avoid unnecessary re-runs
  // when data object reference changes but data remains the same
  const dataHash = JSON.stringify(data);

  // Single effect to manage validation schema lifecycle
  useEffect(() => {
    // Set validation schema when data is available
    if (data != null) {
      const validationSchema = schemaFactory(data);
      setClientValidationSchema(key, validationSchema);
    } else {
      // Clear validation schema when no data
      setClientValidationSchema(key, null);
    }

    // Re-validate all touched fields when client validation schema changes
    const touchedFieldNames = Object.keys(touchedFields);
    if (touchedFieldNames.length > 0) {
      // Use setTimeout to ensure the client validation schema update has propagated
      // before triggering re-validation (fixes race condition)
      setTimeout(async () => {
        return trigger(touchedFieldNames);
      }, 1);
    }

    // Cleanup on unmount or when dependencies change
    return () => {
      setClientValidationSchema(key, null);
    };
    // Only re-run when data (dataHash) or key changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dataHash, key]);
};

/**
 * Helper function to create a veto looseObject schema for a single field with nested path support.
 *
 * Parses field paths (dot-notation) and creates properly nested loose object schemas with array support.
 * All intermediate objects and arrays are marked as optional to allow partial data structures.
 * Numeric segments in the path are treated as array indices, and the parent field is wrapped in an array schema.
 * Supports flat arrays (arrays of primitives) via the special `__FLAT__` key.
 *
 * **Important:** The fieldSchema should typically use `.nullish()` to allow empty values. This is because:
 * - Base validation (passed to Form) handles "required" constraints
 * - Client validation adds dynamic, context-dependent rules (e.g., "username already exists")
 * - Form data processing converts empty strings in flat arrays to `null` (not `undefined`)
 * - `.nullish()` accepts both `null` and `undefined`, while `.optional()` only accepts `undefined`
 *
 * This pattern ensures client validation only validates non-empty values, while base validation
 * enforces required fields and basic constraints (min length, format, etc.).
 *
 * @param name - The dot-separated path to the field (e.g., 'username', 'user.profile.email', 'items.0.name', 'tags.0.__FLAT__')
 * @param fieldSchema - The veto validation schema for the field. Should typically use `.nullish()` to allow empty values.
 * @returns A nested loose object schema matching the field path structure with proper type inference
 *
 * @example
 * ```tsx
 * // Typical usage: base validation handles "required", client validation adds dynamic rules
 * // Base validation (in Form component)
 * const baseSchema = veto({ username: vt.string({ min: 3 }) }); // Required + min length
 *
 * // Client validation (dynamic check for existing usernames)
 * const { data: userData } = useUserQuery(userId);
 * useClientValidation(userData, (data) =>
 *   clientValidationSchemaByName(
 *     'username',
 *     vt.string()
 *       .refine(
 *         (value) => !data.existingUsernames.includes(value),
 *         { message: 'Username already taken' }
 *       )
 *       .nullish() // Allow empty - base validation handles "required"
 *   )
 * );
 * ```
 *
 * @example
 * ```tsx
 * // Nested field path with dynamic validation
 * clientValidationSchemaByName(
 *   'user.profile.email',
 *   vt.string()
 *     .refine(
 *       (value) => !reservedEmails.includes(value),
 *       { message: 'This email is reserved' }
 *     )
 *     .nullish()
 * )
 * // => objectLoose({ user: objectLoose({ profile: objectLoose({ email: ... }).optional() }).optional() })
 * ```
 *
 * @example
 * ```tsx
 * // Array of objects with dynamic validation
 * clientValidationSchemaByName(
 *   'items.0.tag',
 *   vt.string()
 *     .refine((value) => !forbiddenTags.includes(value), { message: 'Tag not allowed' })
 *     .nullish()
 * )
 * // => objectLoose({ items: array(objectLoose({ tag: ... })).optional() })
 * ```
 *
 * @example
 * ```tsx
 * // Flat array (array of primitives) with dynamic validation
 * clientValidationSchemaByName(
 *   'tags.0.__FLAT__',
 *   vt.string()
 *     .refine((value) => !forbiddenWords.includes(value), { message: 'Word not allowed' })
 *     .nullish()
 * )
 * // => objectLoose({ tags: array(vt.string().refine(...).nullish()).optional() })
 * ```
 */
export const clientValidationSchemaByName = <T extends VetoTypeAny>(
  name: string,
  fieldSchema: T,
) => {
  const segments = name.split('.');

  // Build schema from innermost to outermost
  let schema: VetoTypeAny = fieldSchema;

  // Process segments in reverse order to build nested structure
  for (let i = segments.length - 1; i >= 0; i -= 1) {
    const segment = segments[i];

    const isNumeric = /^\d+$/.test(segment);
    const isFlatArrayKey = segment === flatArrayKey;

    if (isFlatArrayKey) {
      // Skip the __FLAT__ key - it's just a marker for flat arrays
      // The schema is already correct (primitive type), just continue
      // eslint-disable-next-line no-continue
      continue;
    }

    if (isNumeric) {
      // Current segment is an array index - wrap current schema in optional array
      schema = array(schema).optional();
    } else {
      // Current segment is a field name - wrap in objectLoose
      // Make it optional if it's an intermediate object (not the root)
      const obj = objectLoose({
        [segment]: schema,
      });
      schema = i > 0 ? obj.optional() : obj;
    }
  }

  return schema;
};
